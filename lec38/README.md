# Scooped allocators. Атрибуты. Move-семантика (начало)

## Scooped allocators

```
#include <iostream>
#include <vector>
#include <string>
#include <scoped_allocator>

// 9.6. Scooped allocators.
template <typename T>
using MyAlloc = std::allocator<T>;



int main() {
    using MyString = std::basic_string<char, std::char_traits<char>, MyAlloc<char>>;

    MyAlloc<MyString> alloc;
    std::vector<MyString, MyAlloc<MyString>> v(alloc);

    v.push_back("abs");
    v.push_back("cde");
}
```

Что тут не так?

Я тут хочу, чтобы внешний и внутренний контейнер работал на одном контейнер.

Тут мы создадим вектор и строку на нестандартном аллокаторе, но каждый аллокатор будет разный, т.е у нас будет новая строка он будет создавать новый объект аллокатора.

А мы хотели, чтобы он не создавал новый объект аллокатора.

И в STL есть такая вещь как 

```
std::scooped_allocator_adaptor<MyAlloc<MyString>>
```

И вот тогда у нас новая строка будет создаваться на том же аллокаторе, что и предыдущие.

А что если мы хотим, чтобы на каждом уровне были разные аллокаторе, тогда мы можем передать несколько аллокаторов в адабтор.

## uses_allocator

```std::uses_allocator<T, Alloc>```

Есть такая штука, которая возвращает *true*, если Т может
принимать аллокатор.


## Атрибуты

**[[ atribyt-list ]]**

Есть еще синтакс, смотри cpp-reference

Можно пометить функцию переменную и еще что то и это влияет на оптимизацию

## no_unique_address

К примеру это последно, если вспомнить про Empty base optimization


## nodiscard

Самый распространенный атрибут, если значение функции не используется (т.е дискардится)

компилятор будет говорит ворнинг, если функция будет дискардится

Пример функий, который точно нужно писать это, если результат функции нужно сохранить, иначе пойдет что то не так

оператор нью, метод аллокайт у аллокатора.

К слову **empty**, проверка на пустоту контейнера тоже помечена **[[nodiscard]]**, Почему так?? потому что можно понять *empty* как глагол как *clear*

## deprecated

Когда api проектируем, туда сюда хз

## maybe_unused

Ставится перед аргументами функции иногда ну и воообще перед переменными, это сделано, чтобы компилятор не жаловался на неизпользуемые перемеными.

Зачем, если можно просто не давать имя переменной?

Есть случай для шаблонной функции, когда он не используется в зависимости от некоторый шаблонных штук.

## likely/unlikely

Классный атрибут

likeely ставится после if подсказывая, что это ветка if будет наиболее вероятно, чем альтернативна

Это помогает бренч предикшен делать и соответсвенно лучше оптимизировать

## asume (since c++23)

Можно подсказать, к примеру что x < 100 будет, и тогда другие ассемблерные интсрукции


# X Move semantics and rvalue-reference

## 10.1 idea of move semantivs, Rule of five

Сколько строк будет создано? 

```
vector<string> v;
v.push_back("abs");
```

У нас сигнатура ```push_back(const string&)``` и здесь у нас константая ссылка, а мы передаем сишную строку.

Создается временный объект, сишная строка конвентируется к стрингу, к которому привязывается константная ссылка.

Потому у нас написано ```new (ptr) T(value)``` Т.е вызвается placement new, в котором создается новый стринг, который положится в вектор, а потом у нас унижтажается временный стринг.

причем даже если мы напишем ```string("abs)``` но это все равно не поможет, потому что это просто явное запись.

## Почему emplace_back не решает глобально проблему?

Частично можно решить нас написав *emplace_back*, однако глобально мы не решили. Так как пусть у нас вектор векторов стрингов.
```
template <typename... Args>
emplace_back(const Args&... args) {
    ...
    new (ptr) T(args);
}
```

## move конструктор и move operator присваивания

Идея в том, что мы хотим перемащать поля класса, когда нам не нужно как то сохранять объект от которого мы муваемся

### реализация на примере string

Пока что объяснить что такое ```T&&``` мы не можем, а просто верим, что написав так у нас будет все хорошо.

Также мы хотим, чтобы тот объект из которого мы мувнули был корректен для изпользования.

```
class string {
    string(string&& other)
    : arr(other.arr)
    , sz(other.sz)
    , cap(other.cap) {
        other.arr = nullptr;
        other.sz = other.cap = 0;
    }

    string& operator=(string&& other) {
        this->clear();
        arr = other.arr;
        other.arr = nullptr;
        sz = other.sz;
        cap = other.cap;
        other.cap = other.sz = 0;

        return *this;
    }

char* arr;
size_t sz;
size_t cap;
};
```