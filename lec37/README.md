## Версии operator new

У оператора new есть 22 версии.
Есть версия, которая 2-ым элементом принимает 
std::nothrow. Она возвращает nullptr

``` new (std::nothrow) int(1UL); ```

Бывает new с произвольными наборами параметров.

```
void* new(size_t n, user-defined-args...);

new ("123", 2) int(5);

void operator delete(void* ptr, user-defined-args...);
```

size_t n неявно само придет первым параметром. А также delete нужно, вызывать с таким же набором команд.

**Но у оператора delete нет такой конструкции**
``` operator delete(ptr, "4543", 425); ```

Бывает случай, когда компилятор сам вызвывает кастомный delet

Пусть у нас есть класс, который в конструкторе вызывает исключения

```
struct S {
    S() {
        throw 1;
    }

int main() {
    try {
        S* p = new(1, 3.14) S();
    } catch (...) {
        std::cout << "caught!";
    }
}
};
```

Если вы в динамической памяти в конструктор вызывает исключение, то под капотом гарантируется вызов оператора delete с такими же параметрами как и new

В данном случае будет

```
1 bytes allocated with custom new 1 3.14
custom delete called 1 3.14
caught!
```

А что если мы высзвали нью с квадратными скобками
и 5 элемент вызвал исключение

```
struct S {
    inline static int count = 0;
    S() {
        ++count;
        if(count == 5) {
            throw 1;
        }
        std::cout << "Created!\n";
    }

    ~S() {
        std::cout << "destroyed!\n";
    }
};

18[] bytes allocated
Created!
Created!
Created!
Created!
destroyed!
destroyed!
destroyed!
destroyed!
caught!
```

Компилятор под капотом побеспокоился за нас и вызвал 4 деструкторов после чего вызвано исключение


## Оператор delete и вуртуальный деструктор

```
struct Base {
    Base() { std::cout << "created Base\n"; }
    ~Base() { std::cout << "destroyed Base\n"; }
};

struct Derived : Base {
    Derived() { std::cout << "created Derived\n"; }
    ~Derived() { std::cout << "destroyed Derivedn\n"; }
};

```

И пусть мы в мейне написали

```
Base* p = new Derived;
delete p;
```

Как мы знаем, если деструктор не виртуальный то у нас вызовется деструктор Base?

Откуда оператор delete знает, какой ему дестуктор вызвать
и по какому адрессу?

Пусть мы создали массив дерийвд, и привели к бейзу и вызвали delete[] => у нас вызовется деструкторы для бейза
причем он будет ходит так думая, что у нас бейз
=> Это всегда UB, Даже сделав виртуальный десткутор operator delete[] не спасет, а delete уже все хорошо будет.

## Оператор new как член класса

Можно прямо в классе определить опрератор new, тогда при
вызове оператора new для этого класса вызовется его версия, а для остальных уже глобальная.

Все они считаются static по умолчанию, поэтому не нужно дописывать.

## Правильная реализация оператора new из стандартной библиотеке

Оператор new всегда выделяет хотя бы 1 байт.

В операторе new еще есть прослойка с ***new_handler***, 
в которой по умолчанию стоит nullptr, однако через
***std::set_new_handler** можно кинуть функцию, чтобы 
она обрабатывала перед **bad_alloc**.

В цикли while пока у нас пойнтер nullptr или nandler не nullptr мы заходим в тело цикла, где вызываем обраточик

Также она помечена как слабый символ, чтобы можно было переопределять.


## Запрет создания объектов T на кучи или на стеке. destroying delete 

1) Пусть у нас есть какой-то класс и мы хотим запретить ему
создаваться на стеке, т.е только на куче. Что делать?

Давайте сделаем деструктор приватным, а в **с++20** определим ``` void T::operator delete(T* ptr, std::destroying_delete_T, size_t count) ```


2) Пусть у нас есть какой-то класс T и мы хотим ему запретить создаваться на куче. Что делать?

Давайте сделаем ``` new = delete ``` внутри его класса.


## Выравнивание, пример UB из-за нарушения выравнивания

```
int main() {
    int* a = new int[10];
    char* ac = reinterpret_cast<char*>(a);
    ++ac;
    int* b = reinterpret_cast<int*>(ac);

    *b = 1;
    int x = *b;
    std::cout << x;
    delete[] a;
}
```

Что в этом коде не так. Если его запустить с санитайзерами то он падает (т.е ошибка санитайзеров).

Вот как раз здесь указатель на int, с численным значением 1 по модулю 4.

у нас есть машинное слово 8 byte, поэтому когда у нас не выравнено как в примере, где int кладетсся на стеке бакетов некоторые процессоры не могу это прочитать на уровне ассемблера и кидают RE.

есть такая функция 
```
void* allign(std::size_t aligment,
            std::size_t size,
            void*& ptr,
            std::sizet& space)
```

Когда у вас есть какой-то пойнтер и вы хотите получить пойнтер выравненый по нужному адрессу.

Вы кладете пойнтер и буффер размера space. То по чему нужно выравнить и размер.

## Ключевые слова alignof и alignas

Как узнать какой нужен alignment?

```std::size_t alignof(type-id) ```

В стек аллокаторе мы заводим массив чаров, и допустим мы хотим, чтобы он был выравнен определенное, большое чем стандартное, к примеру по 4. Пишется перед объявлением.
Можно писать в структуре.

``` 
alignas(type-id) 

alignas(4) chara arr[46];

struct alignas(float) struct_float {};
```

Еще есть ```void* std::aligned_alloc(std::size_t aligment, std::size_t size)```

А почему, когда мы выделяем *malloc* или *new* то не думаем об выравнивание?

Потому, что они по стандарту должны быть выравнены по максимальному значению стандартных типов.

``` std::max_align_t ``` Это тип, у которо выравние маскимально среди стандартных типов. Только для этого он и нужен.

## Битовые поля

Мы можем попросить, чтобы структура хранила несколько бит, а не байт

```
struct S {
    unsigned int b : 3; // value are 0...7
}

int main() {
    S s = {6};
    ++s.b;
    std::cout << s.b; // 7
    ++s.b;
    std::cout << s.b; // 0
}
```

Однако вроде если засунуть, больше чем нужно это UB.