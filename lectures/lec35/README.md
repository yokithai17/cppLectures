## Идея аллокаторов

Вот у нас есть List, и мы хотим 100000 добавить и также удалить, и заметим, что каждый ***insert*** вызывается оператор ***new***, т.е обращение к операционке, что на самом деле работает очень долго

Ассимпотика любого контейнера не учитывает вызов оперератора ***new***

Заметим, что не всегда нужная динамическмя память, к примеру нам нужно лист размера 100, который явно поместиться на стек.

Соответсвенно это нас подвотит к созданию аллокатору.

Container -> allocator_traits -> allocator -> operator new -> malloc -> os

# Это лишь первое приближение

## Стандартные операции аллокаторов 

``` T* allocate(size_t count); ```

Мы хотим аллоцировать память под ***count*** Объектов типа T

``` void deallocate(T* ptr, size_t count);```

Деаллоцирование памяти, причем мы должны передавать такой же ***count*** с каким аллоцировали


``` 
template <typename U, typename... Args>
    void construct(U* ptr, const Args&... args);
```

Конструированте по адрессу объект 

``` 
template <typename U>
void destroy(U* ptr);
```

Вызов дестркутора


## PoolAllocator

Он выделяет большой массив, и на нем строится объекты

## StackAllocator

Как пул аллокатор только на стеке он хранит в себе массив чаров на стеке.

## Решение проблем

Когда мы имеем дело аллокатора в контейнере мы обычно должны аллоцировать не тип T, а какой-то другой тип.

Был придуман костыль в виде rebind.

``` 
template <typename U>
struct rebind {
    using other = Allocator<U>;
};

typename Alloc::rebind<Node>::other alloc;
```

Почему бы не сделать аллокатор шаблонным шаблонным типом?
``` 
template <typename T, template<typename> Alloc = std::allocator>
```

Никто не обещал, что всего один параметр, или вообще, что не параметр, а переменная, к примеру StackAllocator

## Empty Base Optimization

```
struct A {};

struct B : A {
    int x;
};

int main() {
    std::cout << sizeof(A); // 1
    std::cout << sizeof(B); // 4
}
```


## Staeful allocators and allocator_traits

Вот что я хочу делать, если я копирую аллокатор

Я не хочу аллоцировать новый массив, если мы говорим о пул аллокаторе.

И вот тут можно хранить ***shared_ptr***

или же можно зависти отедльную структуру пул, в котором уже менеджемнт памяти.

### Что такое allocator_trairs

Все аллокаторый схожи и имеют 4 обязательных метода,
т.е контейнеры обращаются не к аллокаторам а к аллокатор трейтсу.

```
template <typename Alloc>
struct allocator_traits;
```

Мы никогда не создаем объектов аллокатор трейтс