## set и multiset

Понятно, что set это тоже самое, что и map, только у него не пара ключ-значение, а только ключ
 
<br>
multimap хранит несколько зачение у ключа, нужно для lower and upper bound, еще есть equal_range(key) возвращает пару ключией (анлогично вызову lower and upper bound).

## unordered_map (since c++11)
Поговорим об абстракнтой хеш таблицы
hash : Key -> int
pos = hash(obj) % M

В нашем случае есть 
```
template <typename T>
std::hash<int>();   
```
| opeartions | expected time |
|:------------:|:---------------:|
| insert     | *O(1)         |
| erase      | *O(1)         |
| find       | *O(1)         |
| reserve    |  O(n)         |

<br>
Как реализовать случай колизиия

- **Метод открытоый адресации:**
    <br> если мы видим, что занята ячейка, то идем в следующие ячейку. Тогда заметим, что нужно будет флаг иметь в каждой ячейки удалили мы или нет.
    Однако мы всегда дойдем до большого числа M и нужно будет рехэш делать. Однако заметим, что нужно будет рассматривать только простые числа для M.

- **Метод цепочек**
    <br> В каждой ячейке мы будет хранить связный список.

### Первое приближение хэш таблицы
```
vector<forward_list<Node>> arr;

struct Node {
    pair<const Key, Value> kv;
}
```

Как теперь мы работает insert : мы по форвард листу находим, если нет делаем push_front.

Аналогично erase.

Есть такая вещь ***double load_factor();*** Эта такая разница загруженных ребят к всего бакетам, а также есть такая вещь как ***max_load_factor()*** после каторого идет рехэш (переалоцирование).

### Второе приближение хэш таблице

Первое приближение хорошо работает, если бы не было иттераторов.

Будем делать один большой ***forward_list***
Теперь мы в ячейках мы храним указатели на форвард лист
```
private:
    vector<Node*> arr;
    forward_list<Node> fl;
``` 


Теперь поймем как нам идти по форавард листу.
```
struct Node {
    pair<const Key, Value> kv;
    uint64_t hash
};
```

Поймем как сделать ***insert***
проходимся по бакету, если его не было мы вставляем его в конец, если же не было бакета, то просто вставляем его в начало листа.

Поймем как сделать ***erase*** Есть 2 пути
1) это забить на форвард лист, и хранить
двусвязный список (легкий путь. microsoft)

2) Давайте хранить указатель не на настоящий бакет, а на конец предществуещего

Мы пойдем по второму пути

Как работает ***insert :***

- Если мы делаем вставку в начало или в конец бакета то все окей

- Если мы хотим добавить новый бакет, то мы берем хэш челика первой ячейки и поймем кому нужно обновить указатель добивив в начало листа новый узел

Как работает ***erase***

Аналогично второй вставке, мы переходим по челику переставляем указатель на следующий, если он имеет новый хэш мы делаем нульптр, и удаем ноду.

Как делать ***rehash***

Последовательно делаем ***erase and insert*** 

Давайте вспомним как обяъвлен unordered_map
```
template <typename Key, typename Value, typename Hash, typename Equal>
```

Если мы делаем ***find, insert***, и если кто-то вызвал исключение, то все хорошо, так как мы еще ничего не вставили.

Во время рехэша, тоже все норм, так как мы храним hash.